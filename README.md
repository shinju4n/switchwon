# 스위치원 프론트엔드 과제

실시간 환율을 조회하고 원화↔외화 환전을 수행하는 서비스

## 기술 스택

Core : Next.js 16 (App Router), TypeScript
Package Manager : pnpm
Styling : tailwind CSS, shadcn/ui (component library)
State & Data Fetching : TanStack Query, Zustand
Form & Validation: React Hook Form, zod
ETC: prettier, husky, lint-stage

## 의사 결정 요소들

구현을 하면서 고민을 했던 요소들입니다.

### 1. 토큰 저장 방식

초기에 토큰 저장 방식에 대해서 고민했습니다.

- LocalStorage
- Cookie (httpOnly)

LocalStorage에 저장하는 방식은 구현이 간단하지만 XSS 공격 취약 및 SSR 활용이 불가하기 떄문에 Cookie에 토큰을 선택하는 방식을 채택했습니다.

### 2. CORS 및 httpOnly 쿠키 제약 해결

쿠키 방식을 선택한 후, 실제 API를 호출하는 과정에서 백엔드 규격과 충돌하는 문제가 발생했습니다.

문제 상황: 백엔드 API는 모든 요청 헤더에 Authorization: Bearer {token}을 요구합니다. 하지만 httpOnly 쿠키는 보안상 클라이언트 코드(JS)에서 값을 꺼낼 수 없기 때문에, 브라우저가 직접 헤더에 토큰을 담아 보낼 방법이 없었습니다. 게다가 백엔드 서버에 CORS가 설정되어 있지 않아 브라우저에서의 직접 호출 자체가 차단된 상태였습니다.

해결 모색:

1. 처음에는 `next.config.js`의 `rewrites` 기능을 검토했습니다. 하지만 `rewrites`는 단순한 주소 연결일 뿐, 서버에 저장된 쿠키를 읽어 헤더에 토큰을 동적으로 주입하는 로직을 담을 수 없다는 한계가 있었습니다.
2. 따라서 단순 포워딩이 아닌, 직접 요청을 가로채서 가공할 수 있는 `BFF(Backend For Frontend` 방식이 유일한 해결책이라고 판단했습니다.

최종 해결: `app/api/proxy/[...path]` 경로에 Catch-all Route를 구현했습니다.

1. 클라이언트가 프록시 경로로 API를 요청하면 Next.js 서버가 이를 수신합니다.
2. 서버는 쿠키에서 토큰을 꺼내 헤더에 주입합니다.
3. 서버 대 서버 통신을 통해 CORS 문제를 우회하며 백엔드에 데이터를 요청하고 응답 값 그대로 클라이언트에 전달합니다.

이 구조를 통해 보안(쿠키)과 백엔드 요구 규격(헤더 토큰) 사이의 간극을 해결했습니다.

### 3. SSR 및 Prefetch 환경에서의 데이터 무결성 확보

BFF(프록시) 구조를 도입한 후, Next.js의 서버 사이드 렌더링(SSR)과 useSuspenseQuery를 결합하는 과정에서 발생한 추가적인 기술적 문제들을 다음과 같이 해결했습니다.

1. 서버에서의 API 주소 인식 문제
   문제: 브라우저와 달리 서버(Node.js)는 /api/proxy/... 같은 상대 경로가 어디를 가리키는지 알지 못해 에러가 발생했습니다.

해결: 서버에서 실행될 때는 http://localhost:3000 같은 전체 주소(절대 경로)를 앞에 붙여주도록 유틸리티 함수를 만들어 해결했습니다.

2. 서버에서 API 호출 시 쿠키 누락 문제
   문제: 서버 컴포넌트에서 프록시 API로 데이터를 요청할 때, 브라우저가 보낸 쿠키가 자동으로 전달되지 않았습니다. 이로 인해 프록시 API가 요청을 거부하여 서버 렌더링이 실패했습니다.

해결: 서버가 받은 쿠키를 직접 꺼내서 fetch 헤더에 수동으로 담아 보내주는 방식으로 인증 문제를 해결했습니다. 덕분에 서버에서도 로그인된 상태로 데이터를 미리 가져올 수 있게 되었습니다.

3. 서버 전용 코드의 클라이언트 충돌 문제
   문제: 서버에서 쿠키를 꺼내기 위해 쓴 next/headers가 클라이언트 코드(브라우저)에 섞여 들어가면서 빌드 에러가 발생했습니다.

해결: if (isServer) 조건문을 사용하고, 필요할 때만 모듈을 불러오는 방식(await import)을 적용해 서버와 클라이언트의 코드가 꼬이지 않도록 분리했습니다.
